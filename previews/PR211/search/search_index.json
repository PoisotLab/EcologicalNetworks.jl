{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#species-interaction-networks-analyses-in-julia","title":"Species Interaction Networks analyses in Julia","text":"<p>foo</p>"},{"location":"getting_started/demonstration/","title":"Building a network","text":""},{"location":"getting_started/demonstration/#building-a-network","title":"Building a network","text":"<p>Abstract</p> <p>Before getting started with the package itself, we will see how we can build a network, access its content, and iterate over the interactions. This page is intended to give you some intuitions about how the type system works, before reading more of the manual.</p> <pre><code>using SpeciesInteractionNetworks\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#list-of-species","title":"List of species","text":"<p>We will create a very small network, made of four species and their interactions. The first step is to define a list of species:</p> <pre><code>species = [:fox, :vole, :hawk, :turnip]\n</code></pre> <pre><code>4-element Array{Symbol,1}:\n :fox\n :vole\n :hawk\n :turnip\n</code></pre> <p>In order to make sure that we are explicit about the type of network we are working with, we will create a representation of this list of species that is unipartite:</p> <pre><code>nodes = Unipartite(species)\n</code></pre> <pre><code>Unipartite{Symbol}([:fox, :vole, :hawk, :turnip])\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#list-of-interactions","title":"List of interactions","text":"<p>As with species, we want to represent interactions in a way that captures ecological information. In this case, we will use binary interactions (true/0), and work from a matrix, where the rows are the source of the interaction, and the column is its destination. It means that interactions go from predator to preys.</p> <pre><code>int_matrix = Bool[\n0 1 0 0;\n0 0 0 1;\n0 1 0 0;\n0 0 0 0\n]\n</code></pre> <pre><code>4\u00d74 Array{Bool,2}:\n 0  1  0  0\n 0  0  0  1\n 0  1  0  0\n 0  0  0  0\n</code></pre> <p>About interaction as matrices</p> <p>By specifying interactions as a matrix, it is fundamental that columns and orders are in the correct order. There are alternative ways to specify networks that do not rely on matrices (using tuples or pairs), but because most species interaction network data are represented as matrices, this is supported by the package.</p> <p>As this network is binary, we will wrap this matrix into a <code>Binary</code> collection of interactions:</p> <pre><code>edges = Binary(int_matrix)\n</code></pre> <pre><code>Binary{Bool}(\n  [1, 2]  =  true\n  [3, 2]  =  true\n  [2, 4]  =  true)\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#assembling-the-network","title":"Assembling the network","text":"<p>The network itself is a collection of nodes and edges. There are a number of specific checks performed when creating the network, to ensure that we cannot create an object that makes no sense.</p> <pre><code>network = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>SpeciesInteractionNetwork{Unipartite{Symbol},Binary{Bool}}(Unipartite{Symbol}([:fox, :vole, :hawk, :turnip]), Binary{Bool}(\n  [1, 2]  =  true\n  [3, 2]  =  true\n  [2, 4]  =  true))\n</code></pre> <p>The networks are iterable, i.e. we can walk through them, specifically one interaction at a time:</p> <pre><code>for interaction in network\nprintln(interaction)\nend\n</code></pre> <pre><code>(:fox, :vole, true)\n(:hawk, :vole, true)\n(:vole, :turnip, true)\n</code></pre> <p>Internally, this is done by only returning the pairs of species that do not have a value of zero.</p> <p></p> <p></p>"},{"location":"getting_started/demonstration/#basics-of-network-exploration","title":"Basics of network exploration","text":"<p>We can also get a list of the species that establish an interaction with a given species (in this case, predators):</p> <pre><code>predecessors(network, :vole)\n</code></pre> <pre><code>Set{Symbol} with 2 elements:\n  :fox\n  :hawk\n</code></pre> <p>Or the species witch which a given species establishes interactions (in this case, preys):</p> <pre><code>successors(network, :fox)\n</code></pre> <pre><code>Set{Symbol} with 1 element:\n  :vole\n</code></pre> <p>Further</p> <pre><code>interactions(subgraph(network, [:fox, :vole, :turnip]))\n</code></pre> <pre><code>2-element Array{Tuple{Symbol,Symbol,Bool},1}:\n (:fox, :vole, 1)\n (:vole, :turnip, 1)\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#networks-are-editable","title":"Networks are editable","text":"<p>The content of networks can be modified. For example, to circumvent the issue of needing to write the interaction matrix in the correct order, we can start with an empty network:</p> <pre><code>netsize = (richness(nodes,1), richness(nodes, 2))\nedges2 = Binary(zeros(Bool, netsize))\nnetwork2 = SpeciesInteractionNetwork(nodes, edges2)\ninteractions(network2)\n</code></pre> <pre><code>Tuple{Symbol,Symbol,Bool}[]\n</code></pre> <p>We can then add the interactions one by one:</p> <pre><code>for interaction in [(:fox, :vole), (:hawk, :vole), (:vole, :turnip)]\nnetwork2[interaction...] = true\nend\ninteractions(network2)\n</code></pre> <pre><code>3-element Array{Tuple{Symbol,Symbol,Bool},1}:\n (:fox, :vole, 1)\n (:hawk, :vole, 1)\n (:vole, :turnip, 1)\n</code></pre>"},{"location":"getting_started/types/","title":"Type system","text":""},{"location":"getting_started/types/#the-type-system","title":"The type system","text":"<p>The package relies on a compreensive system of types to represent networks. The purpose of the type system is to ensure that data are represented without ambiguities, but also to specialize the algorithm applied to each type of network.</p> <p>The networks are represented as sparse matrices, for performance reasons. In practice, networks are standard Julia arrays, in that they can be accessed by position, sliced, have a <code>size</code> and <code>axes</code>, etc..</p> <p># <code>SpeciesInteractionNetworks.SpeciesInteractionNetwork</code> \u2014 Type.</p> <pre><code>SpeciesInteractionNetwork{P&lt;:Partiteness, E&lt;:Interactions}\n</code></pre> <p>A <code>SpeciesInteractionNetwork</code> type represents a species interaction network.</p> <p>This type has two fields: <code>nodes</code> (a <code>Partiteness</code>), and <code>edges</code> (an <code>Interactions</code>). Because these two types are parametric, we can learn everything there is to know about the data structure in a network by looking at the type alone.</p> <p>For example, a bipartite quantitative network where species are symbols and interactions are 32-bits floating point numbers will have the type</p> <pre><code>SpeciesInteractionNetwork{Bipartite{Symbol}, Interactions{Float32}}\n</code></pre> <p>This enables very specialized dispatch and indexing thoughout the package.</p> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#representing-species","title":"Representing species","text":"<p># <code>SpeciesInteractionNetworks.Partiteness</code> \u2014 Type.</p> <pre><code>Partiteness{T}\n</code></pre> <p>The species in a network are stored in a parametric sub-type of <code>Partiteness</code>. By default, this can be <code>Unipartite</code> or <code>Bipartite</code>. The inner type <code>T</code> indicates what types can be used to represent species. Note that species cannot be represented as integers, and will instead have a name. We recommend using strings or symbols.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Bipartite</code> \u2014 Type.</p> <pre><code>Bipartite{T &lt;: Any} &lt;: Partiteness{T}\n</code></pre> <p>A bipartite set of species is represented by two sets of species, called <code>top</code> and <code>bottom</code>. Both set of species are represented as <code>Vector{T}</code>, with a few specific constraints:</p> <ol> <li><code>T</code> cannot be a <code>Number</code> (i.e. nodes must have names, or be other objects)</li> <li>All species in <code>top</code> must be unique</li> <li>All species in <code>bottom</code> must be unique</li> <li>No species can be found in both <code>bottom</code> and <code>top</code></li> </ol> <p>source</p> <p># <code>SpeciesInteractionNetworks.Unipartite</code> \u2014 Type.</p> <pre><code>Unipartite{T &lt;: Any} &lt;: Partiteness{T}\n</code></pre> <p>A unipartite set of species is represented by a single set of species, called <code>margin</code> internally. Both set of species are represented as <code>Vector{T}</code>, with a few specific constraints:</p> <ol> <li><code>T</code> cannot be a <code>Number</code> (i.e. nodes must have names, or be other objects)</li> <li>All species in <code>margin</code> must be unique</li> </ol> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#representing-interactions","title":"Representing interactions","text":"<p># <code>SpeciesInteractionNetworks.Interactions</code> \u2014 Type.</p> <pre><code>Interactions{T}\n</code></pre> <p>The interactions in a network are stored in a parametric sub-type of <code>Interactions</code>. By default, this can be <code>Binary</code>, <code>Quantitative</code>, and <code>Probabilistic</code>. The inner type <code>T</code> indicates what types are used to represent interactions.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Binary</code> \u2014 Type.</p> <pre><code>Binary{Bool} &lt;: Interactions{Bool}\n</code></pre> <p>Binary interactions are represented (internally) as a sparse matrix of Boolean values.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Quantitative</code> \u2014 Type.</p> <pre><code>Quantitative{T &lt;: Number} &lt;: Interactions{T}\n</code></pre> <p>Quantitative interactions are represented (internally) as a sparse matrix of numbers.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Probabilistic</code> \u2014 Type.</p> <pre><code>Probabilistic{T &lt;: AbstractFloat} &lt;: Interactions{T}\n</code></pre> <p>Probabilistic interactions are represented (internally) as a sparse matrix of floating point values. The values must be in the unit interval for the type to be valid.</p> <p>source</p>"}]}