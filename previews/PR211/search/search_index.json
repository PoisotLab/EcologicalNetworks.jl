{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Species Interaction Networks analyses in Julia foo","title":"Home"},{"location":"#species-interaction-networks-analyses-in-julia","text":"foo","title":"Species Interaction Networks analyses in Julia"},{"location":"getting_started/demonstration/","text":"Building a network Before getting started with the package itself, we will see how we can build a network, access its content, and iterate over the interactions. This page is intended to give you some intuitions about how the type system works, before reading more of the manual. using SpeciesInteractionNetworks List of species We will create a very small network, made of four species and their interactions. The first step is to define a list of species: species = [:fox, :vole, :hawk, :turnip] 4-element Array{Symbol,1}: :fox :vole :hawk :turnip In order to make sure that we are explicit about the type of network we are working with, we will create a representation of this list of species that is unipartite: nodes = Unipartite(species) Unipartite{Symbol}([:fox, :vole, :hawk, :turnip]) List of interactions As with species, we want to represent interactions in a way that captures ecological information. In this case, we will use binary interactions (true/0), and work from a matrix, where the rows are the source of the interaction, and the column is its destination. It means that interactions go from predator to preys. int_matrix = Bool[ 0 1 0 0; 0 0 0 1; 0 1 0 0; 0 0 0 0 ] 4\u00d74 Array{Bool,2}: 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 As this network is binary, we will wrap this matrix into a Binary collection of interactions: edges = Binary(int_matrix) Binary{Bool}( [1, 2] = true [3, 2] = true [2, 4] = true) Assembling the network The network itself is a collection of nodes and edges. There are a number of specific checks performed when creating the network, to ensure that we cannot create an object that makes no sense. network = SpeciesInteractionNetwork(nodes, edges) SpeciesInteractionNetwork{Unipartite{Symbol},Binary{Bool}}(Unipartite{Symbol}([:fox, :vole, :hawk, :turnip]), Binary{Bool}( [1, 2] = true [3, 2] = true [2, 4] = true)) The networks are iterable, i.e. we can walk through them, specifically one interaction at a time: for interaction in network println(interaction) end (:fox, :vole, true) (:hawk, :vole, true) (:vole, :turnip, true) Internally, this is done by only returning the pairs of species that do not have a value of zero. Basics of network exploration We can also get a list of the species that establish an interaction with a given species (in this case, predators): predecessors(network, :vole) Set{Symbol} with 2 elements: :fox :hawk Or the species witch which a given species establishes interactions (in this case, preys): successors(network, :fox) Set{Symbol} with 1 element: :vole Further subgraph(network, [:fox, :vole, :turnip]) |> interactions 2-element Array{Tuple{Symbol,Symbol,Bool},1}: (:fox, :vole, 1) (:vole, :turnip, 1)","title":"Building a network"},{"location":"getting_started/demonstration/#building-a-network","text":"Before getting started with the package itself, we will see how we can build a network, access its content, and iterate over the interactions. This page is intended to give you some intuitions about how the type system works, before reading more of the manual. using SpeciesInteractionNetworks","title":"Building a network"},{"location":"getting_started/demonstration/#list-of-species","text":"We will create a very small network, made of four species and their interactions. The first step is to define a list of species: species = [:fox, :vole, :hawk, :turnip] 4-element Array{Symbol,1}: :fox :vole :hawk :turnip In order to make sure that we are explicit about the type of network we are working with, we will create a representation of this list of species that is unipartite: nodes = Unipartite(species) Unipartite{Symbol}([:fox, :vole, :hawk, :turnip])","title":"List of species"},{"location":"getting_started/demonstration/#list-of-interactions","text":"As with species, we want to represent interactions in a way that captures ecological information. In this case, we will use binary interactions (true/0), and work from a matrix, where the rows are the source of the interaction, and the column is its destination. It means that interactions go from predator to preys. int_matrix = Bool[ 0 1 0 0; 0 0 0 1; 0 1 0 0; 0 0 0 0 ] 4\u00d74 Array{Bool,2}: 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 As this network is binary, we will wrap this matrix into a Binary collection of interactions: edges = Binary(int_matrix) Binary{Bool}( [1, 2] = true [3, 2] = true [2, 4] = true)","title":"List of interactions"},{"location":"getting_started/demonstration/#assembling-the-network","text":"The network itself is a collection of nodes and edges. There are a number of specific checks performed when creating the network, to ensure that we cannot create an object that makes no sense. network = SpeciesInteractionNetwork(nodes, edges) SpeciesInteractionNetwork{Unipartite{Symbol},Binary{Bool}}(Unipartite{Symbol}([:fox, :vole, :hawk, :turnip]), Binary{Bool}( [1, 2] = true [3, 2] = true [2, 4] = true)) The networks are iterable, i.e. we can walk through them, specifically one interaction at a time: for interaction in network println(interaction) end (:fox, :vole, true) (:hawk, :vole, true) (:vole, :turnip, true) Internally, this is done by only returning the pairs of species that do not have a value of zero.","title":"Assembling the network"},{"location":"getting_started/demonstration/#basics-of-network-exploration","text":"We can also get a list of the species that establish an interaction with a given species (in this case, predators): predecessors(network, :vole) Set{Symbol} with 2 elements: :fox :hawk Or the species witch which a given species establishes interactions (in this case, preys): successors(network, :fox) Set{Symbol} with 1 element: :vole Further subgraph(network, [:fox, :vole, :turnip]) |> interactions 2-element Array{Tuple{Symbol,Symbol,Bool},1}: (:fox, :vole, 1) (:vole, :turnip, 1)","title":"Basics of network exploration"},{"location":"getting_started/types/","text":"The type system The package relies on a compreensive system of types to represent networks. The purpose of the type system is to ensure that data are represented without ambiguities, but also to specialize the algorithm applied to each type of network. The networks are represented as sparse matrices, for performance reasons. In practice, networks are standard Julia arrays, in that they can be accessed by position, sliced, have a size and axes , etc. . # SpeciesInteractionNetworks.SpeciesInteractionNetwork \u2014 Type . SpeciesInteractionNetwork{P<:Partiteness, E<:Interactions} A SpeciesInteractionNetwork type represents a species interaction network. This type has two fields: nodes (a Partiteness ), and edges (an Interactions ). Because these two types are parametric, we can learn everything there is to know about the data structure in a network by looking at the type alone. For example, a bipartite quantitative network where species are symbols and interactions are 32-bits floating point numbers will have the type SpeciesInteractionNetwork{Bipartite{Symbol}, Interactions{Float32}} This enables very specialized dispatch and indexing thoughout the package. source Representing species # SpeciesInteractionNetworks.Partiteness \u2014 Type . Partiteness{T} The species in a network are stored in a parametric sub-type of Partiteness . By default, this can be Unipartite or Bipartite . The inner type T indicates what types can be used to represent species. Note that species cannot be represented as integers, and will instead have a name. We recommend using strings or symbols. source # SpeciesInteractionNetworks.Bipartite \u2014 Type . Bipartite{T <: Any} <: Partiteness{T} A bipartite set of species is represented by two sets of species, called top and bottom . Both set of species are represented as Vector{T} , with a few specific constraints: T cannot be a Number ( i.e. nodes must have names, or be other objects) All species in top must be unique All species in bottom must be unique No species can be found in both bottom and top source # SpeciesInteractionNetworks.Unipartite \u2014 Type . Unipartite{T <: Any} <: Partiteness{T} A unipartite set of species is represented by a single set of species, called margin internally. Both set of species are represented as Vector{T} , with a few specific constraints: T cannot be a Number ( i.e. nodes must have names, or be other objects) All species in margin must be unique source Representing interactions # SpeciesInteractionNetworks.Interactions \u2014 Type . Interactions{T} The interactions in a network are stored in a parametric sub-type of Interactions . By default, this can be Binary , Quantitative , and Probabilistic . The inner type T indicates what types are used to represent interactions. source # SpeciesInteractionNetworks.Binary \u2014 Type . Binary{Bool} <: Interactions{Bool} Binary interactions are represented (internally) as a sparse matrix of Boolean values. source # SpeciesInteractionNetworks.Quantitative \u2014 Type . Quantitative{T <: Number} <: Interactions{T} Quantitative interactions are represented (internally) as a sparse matrix of numbers. source # SpeciesInteractionNetworks.Probabilistic \u2014 Type . Probabilistic{T <: AbstractFloat} <: Interactions{T} Probabilistic interactions are represented (internally) as a sparse matrix of floating point values. The values must be in the unit interval for the type to be valid. source","title":"Type system"},{"location":"getting_started/types/#the-type-system","text":"The package relies on a compreensive system of types to represent networks. The purpose of the type system is to ensure that data are represented without ambiguities, but also to specialize the algorithm applied to each type of network. The networks are represented as sparse matrices, for performance reasons. In practice, networks are standard Julia arrays, in that they can be accessed by position, sliced, have a size and axes , etc. . # SpeciesInteractionNetworks.SpeciesInteractionNetwork \u2014 Type . SpeciesInteractionNetwork{P<:Partiteness, E<:Interactions} A SpeciesInteractionNetwork type represents a species interaction network. This type has two fields: nodes (a Partiteness ), and edges (an Interactions ). Because these two types are parametric, we can learn everything there is to know about the data structure in a network by looking at the type alone. For example, a bipartite quantitative network where species are symbols and interactions are 32-bits floating point numbers will have the type SpeciesInteractionNetwork{Bipartite{Symbol}, Interactions{Float32}} This enables very specialized dispatch and indexing thoughout the package. source","title":"The type system"},{"location":"getting_started/types/#representing-species","text":"# SpeciesInteractionNetworks.Partiteness \u2014 Type . Partiteness{T} The species in a network are stored in a parametric sub-type of Partiteness . By default, this can be Unipartite or Bipartite . The inner type T indicates what types can be used to represent species. Note that species cannot be represented as integers, and will instead have a name. We recommend using strings or symbols. source # SpeciesInteractionNetworks.Bipartite \u2014 Type . Bipartite{T <: Any} <: Partiteness{T} A bipartite set of species is represented by two sets of species, called top and bottom . Both set of species are represented as Vector{T} , with a few specific constraints: T cannot be a Number ( i.e. nodes must have names, or be other objects) All species in top must be unique All species in bottom must be unique No species can be found in both bottom and top source # SpeciesInteractionNetworks.Unipartite \u2014 Type . Unipartite{T <: Any} <: Partiteness{T} A unipartite set of species is represented by a single set of species, called margin internally. Both set of species are represented as Vector{T} , with a few specific constraints: T cannot be a Number ( i.e. nodes must have names, or be other objects) All species in margin must be unique source","title":"Representing species"},{"location":"getting_started/types/#representing-interactions","text":"# SpeciesInteractionNetworks.Interactions \u2014 Type . Interactions{T} The interactions in a network are stored in a parametric sub-type of Interactions . By default, this can be Binary , Quantitative , and Probabilistic . The inner type T indicates what types are used to represent interactions. source # SpeciesInteractionNetworks.Binary \u2014 Type . Binary{Bool} <: Interactions{Bool} Binary interactions are represented (internally) as a sparse matrix of Boolean values. source # SpeciesInteractionNetworks.Quantitative \u2014 Type . Quantitative{T <: Number} <: Interactions{T} Quantitative interactions are represented (internally) as a sparse matrix of numbers. source # SpeciesInteractionNetworks.Probabilistic \u2014 Type . Probabilistic{T <: AbstractFloat} <: Interactions{T} Probabilistic interactions are represented (internally) as a sparse matrix of floating point values. The values must be in the unit interval for the type to be valid. source","title":"Representing interactions"}]}